<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Bootstrap demo</title>
  <!-- <link href="main.css" rel="stylesheet" > -->
  <link href="bootstrap.min.css" rel="stylesheet">
  <style>
    canvas {
      border: 1px solid #000000;
    }
  </style>

</head>

<body >
  <div class="container-fluid">
    <h1>Hello, world!</h1>
    <form id="uploadImg" runat="server">
      <input type="file" id="imgLoader" />
    </form>
    <div class="row">
      <div class="col-md-4">
        <button id="drawing-mode" class="btn btn-info">Drawing mode</button>
      </div>
      <div class="col-md-4">
        <button id="remove" class="btn btn-info" type="button">Remove</button>
      </div>
      <div class="col-md-4">
        <button  id="set-basic-unit" class="btn btn-info" type="button">Set basic unit</button>
      </div>
    </div>
    <div class="row">
      <div class="col-md-12">
        <canvas id="c"></canvas>
      </div>
    </div>
  </div>

  <script src="bootstrap.bundle.min.js"></script>
  <script src="fabric.min.js"></script>
  <script>
var Edge = fabric.util.createClass(fabric.Line, {

type: 'edge',
// initialize can be of type function(options) or function(property, options), like for text.
// no other signatures allowed.
initialize: function(points, options){
  console.log("Edge")
  options = options || {};
  this.points = points || [];
  this.lockScalingFlip = true
  this.lockScalingX = true
  this.lockScalingY = true
  this.callSuper('initialize',points, options);
  this.set('basicUnit',  false)
  this.set('label', options.label || '');
},

toObject: function() {
  return fabric.util.object.extend(this.callSuper('toObject'), {
    label: this.get('label'),
    basicUnit: this.get('basicUnit')
  });
},

_render: function(ctx) {
  this.callSuper('_render', ctx);
  console.log("Render")
  if(this.basicUnit == true) {
    console.log("Render bu")
    ctx.font = '16px Helvetica';
    ctx.fillStyle = '#319';
    ctx.fillText(this.label,  -this.width/2, -this.height/2 + 20);
  } else {
    console.log("Render no bu")
    ctx.font = '11px Helvetica';
    ctx.fillStyle = '#177';
    ctx.fillText(this.label,  -this.width/2, -this.height/2 + 20);
  }

  
  // ctx.fillText(this.label, -this.width/2, -this.height/2 + 20);
}
});


    console.log("OK")
    var line, isDown;
    var drawing = false;
    var $ = function(id){return document.getElementById(id)};

    var drawingModeEl = $('drawing-mode');
    var removeEl = $('remove');
    var setBasicUnitEl = $('set-basic-unit');
    var canvas = new fabric.Canvas("c", {
      isDrawingMode: false,
      //freeDrawingBrush: new fabric.PencilBrush({ decimate: 8 })
    });
    canvas.setHeight(window.innerHeight);
    canvas.setWidth(window.innerWidth - window.innerWidth *0.1);
    //canvas.objectCaching = false;


    removeEl.onclick = function() {
      canvas.getActiveObjects().forEach((obj) => {
        canvas.remove(obj);
      })
    }

    setBasicUnitEl.onclick = function() {
      var ao = canvas.getActiveObject()
      if (!ao || ao.type != 'edge') return ;
      var aolen = getLen(ao);

      canvas.getObjects().forEach((obj) => {
        
        obj.basicUnit = false 
        obj.dirty = true
        obj.label = fixRound(getLen(obj) / aolen);
      });
      ao.basicUnit = true;
      ao.label = 1
      canvas.renderAll()
    }

    drawingModeEl.onclick = function() {
      drawing = !drawing;
      if(drawing) {
        canvas.selection = false;
        drawingModeEl.innerHTML = 'Select mode';
      } else {
        canvas.selection = true;
        drawingModeEl.innerHTML = 'Drawing mode';
      }
      /*
    canvas.isDrawingMode = !canvas.isDrawingMode;
    if (canvas.isDrawingMode) {
      //drawingModeEl.innerHTML = 'Cancel drawing mode';
      //drawingOptionsEl.style.display = '';
    }
    else {
      //drawingModeEl.innerHTML = 'Enter drawing mode';
      
      //drawingOptionsEl.style.display = 'none';
    }
    */
  };


  canvas.on('mouse:wheel', function(opt) {
  var delta = opt.e.deltaY;
  var zoom = canvas.getZoom();
  zoom *= 0.999 ** delta;
  if (zoom > 20) zoom = 20;
  if (zoom < 0.01) zoom = 0.01;
  canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
  opt.e.preventDefault();
  opt.e.stopPropagation();
});

canvas.on('mouse:down', function(opt) {
  var evt = opt.e;
  if (evt.altKey === true) {
    this.isDragging = true;
    this.selection = false;
    this.lastPosX = evt.clientX;
    this.lastPosY = evt.clientY;
  }
});
canvas.on('mouse:move', function(opt) {
  if (this.isDragging) {
    var e = opt.e;
    var vpt = this.viewportTransform;
    vpt[4] += e.clientX - this.lastPosX;
    vpt[5] += e.clientY - this.lastPosY;
    this.requestRenderAll();
    this.lastPosX = e.clientX;
    this.lastPosY = e.clientY;
  }
});
canvas.on('mouse:up', function(opt) {
  // on mouse up we want to recalculate new interaction
  // for all objects, so we call setViewportTransform
  this.setViewportTransform(this.viewportTransform);
  this.isDragging = false;
  this.selection = true;
});
  
canvas.on('mouse:down', function(o){
  if (!drawing) return;
  isDown = true;
  var pointer = canvas.getPointer(o.e);
  var points = [ pointer.x, pointer.y, pointer.x, pointer.y ];

    line = new Edge(points, {
      strokeWidth: 2,
      fill: 'black',
      stroke: 'black',
      originX: 'center',
      originY: 'center'
    });
  
  canvas.add(line);
});

function getLen(line) {
  return Math.sqrt(Math.pow(line.x2 - line.x1, 2) + Math.pow(line.y2 - line.y1,2))
}

function fixRound(f) {
  console.log(f)

  return Math.round(f * 100) / 100
}

canvas.on('mouse:move', function(o){
  if (!drawing) return;
  if (!isDown) return;
  
  var pointer = canvas.getPointer(o.e);
  if(o.e.shiftKey) {
    if( Math.abs(line.y1 - pointer.y) > Math.abs(line.x1 - pointer.x)) {
      line.set({ y2: pointer.y, x2: line.x1 });
    } else {
      line.set({ x2: pointer.x, y2: line.y1 });
    }
    
  } else {
    line.set({ x2: pointer.x, y2: pointer.y });
  }
  var len = getLen(line);
  line.label = fixRound(len);
  canvas.renderAll();
});

canvas.on('mouse:up', function(o){
  isDown = false;
});
    /*
    var text = new fabric.Textbox('Hello world From Fabric JS', {
      width: 250,
      cursorColor: "blue",
      top: 10,
      left: 10
    });
    canvas.add(text)
    */
    document.getElementById('imgLoader').onchange = function handleImage(e) {
      var reader = new FileReader();
      reader.onload = function (event) {
        var imgObj = new Image();
        imgObj.src = event.target.result;
        imgObj.onload = function () {
          var image = new fabric.Image(imgObj);
          /*
          image.scaleToWidth(canvas.getWidth());
          canvas.centerObject(image);
          canvas.add(image);
          canvas.renderAll();
          */
          canvas.setZoom(1);
          canvas.viewportTransform = [1, 0, 0, 1, 0, 0];

          var canvasAspect = canvas.width / canvas.height;
          var imgAspect = image.width / image.height;
          var left, top, scaleFactor;

          if(image.width < image.height) {
            console.log(1)
            if (canvasAspect >= imgAspect) {
              console.log(2)
              var scaleFactor = canvas.height / image.height;
                top = 0;
                left = -((image.width * scaleFactor) - canvas.width) / 2;
                
            } else {
              var scaleFactor = canvas.width / image.width;
                console.log(scaleFactor)
                left = 0;
                top = -((image.height * scaleFactor) - canvas.height) / 2;
                

            }
          } else {
            if (canvasAspect <= imgAspect) {
                var scaleFactor = canvas.width / image.width;
                left = 0;
                top = -((image.height * scaleFactor) - canvas.height) / 2;
            } else {
                var scaleFactor = canvas.height / image.height;
                top = 0;
                left = -((image.width * scaleFactor) - canvas.width) / 2;

            }
          }

          
          canvas.setBackgroundImage(image, canvas.renderAll.bind(canvas), {
            //scaleX: canvas.width / image.width,
            //scaleY: canvas.height / image.height

            top: top,
            left: left,
            originX: 'left',
            originY: 'top',
            scaleX: scaleFactor,
            scaleY: scaleFactor

          });
        }
      }
      reader.readAsDataURL(e.target.files[0]);
    }

  </script>
</body>

</html>